// Code generated by protoc-gen-go. DO NOT EDIT.
// source: capsule8/api/v0/types.proto

package v0

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Network types
type NetworkAddressFamily int32

const (
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNKNOWN NetworkAddressFamily = 0
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_INET    NetworkAddressFamily = 1
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_INET6   NetworkAddressFamily = 2
	NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_LOCAL   NetworkAddressFamily = 3
)

var NetworkAddressFamily_name = map[int32]string{
	0: "NETWORK_ADDRESS_FAMILY_UNKNOWN",
	1: "NETWORK_ADDRESS_FAMILY_INET",
	2: "NETWORK_ADDRESS_FAMILY_INET6",
	3: "NETWORK_ADDRESS_FAMILY_LOCAL",
}
var NetworkAddressFamily_value = map[string]int32{
	"NETWORK_ADDRESS_FAMILY_UNKNOWN": 0,
	"NETWORK_ADDRESS_FAMILY_INET":    1,
	"NETWORK_ADDRESS_FAMILY_INET6":   2,
	"NETWORK_ADDRESS_FAMILY_LOCAL":   3,
}

func (x NetworkAddressFamily) String() string {
	return proto.EnumName(NetworkAddressFamily_name, int32(x))
}
func (NetworkAddressFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type IPv4Address struct {
	Address uint32 `protobuf:"fixed32,1,opt,name=address" json:"address,omitempty"`
}

func (m *IPv4Address) Reset()                    { *m = IPv4Address{} }
func (m *IPv4Address) String() string            { return proto.CompactTextString(m) }
func (*IPv4Address) ProtoMessage()               {}
func (*IPv4Address) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *IPv4Address) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

type IPv4AddressAndPort struct {
	Address *IPv4Address `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Port    uint32       `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *IPv4AddressAndPort) Reset()                    { *m = IPv4AddressAndPort{} }
func (m *IPv4AddressAndPort) String() string            { return proto.CompactTextString(m) }
func (*IPv4AddressAndPort) ProtoMessage()               {}
func (*IPv4AddressAndPort) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *IPv4AddressAndPort) GetAddress() *IPv4Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPv4AddressAndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type IPv6Address struct {
	High uint64 `protobuf:"fixed64,1,opt,name=high" json:"high,omitempty"`
	Low  uint64 `protobuf:"fixed64,2,opt,name=low" json:"low,omitempty"`
}

func (m *IPv6Address) Reset()                    { *m = IPv6Address{} }
func (m *IPv6Address) String() string            { return proto.CompactTextString(m) }
func (*IPv6Address) ProtoMessage()               {}
func (*IPv6Address) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *IPv6Address) GetHigh() uint64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *IPv6Address) GetLow() uint64 {
	if m != nil {
		return m.Low
	}
	return 0
}

type IPv6AddressAndPort struct {
	Address *IPv6Address `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Port    uint32       `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *IPv6AddressAndPort) Reset()                    { *m = IPv6AddressAndPort{} }
func (m *IPv6AddressAndPort) String() string            { return proto.CompactTextString(m) }
func (*IPv6AddressAndPort) ProtoMessage()               {}
func (*IPv6AddressAndPort) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *IPv6AddressAndPort) GetAddress() *IPv6Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPv6AddressAndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type NetworkAddress struct {
	Family NetworkAddressFamily `protobuf:"varint,1,opt,name=family,enum=capsule8.api.v0.NetworkAddressFamily" json:"family,omitempty"`
	// Types that are valid to be assigned to Address:
	//	*NetworkAddress_Ipv4Address
	//	*NetworkAddress_Ipv6Address
	//	*NetworkAddress_LocalAddress
	Address isNetworkAddress_Address `protobuf_oneof:"address"`
}

func (m *NetworkAddress) Reset()                    { *m = NetworkAddress{} }
func (m *NetworkAddress) String() string            { return proto.CompactTextString(m) }
func (*NetworkAddress) ProtoMessage()               {}
func (*NetworkAddress) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

type isNetworkAddress_Address interface {
	isNetworkAddress_Address()
}

type NetworkAddress_Ipv4Address struct {
	Ipv4Address *IPv4AddressAndPort `protobuf:"bytes,10,opt,name=ipv4_address,json=ipv4Address,oneof"`
}
type NetworkAddress_Ipv6Address struct {
	Ipv6Address *IPv6AddressAndPort `protobuf:"bytes,20,opt,name=ipv6_address,json=ipv6Address,oneof"`
}
type NetworkAddress_LocalAddress struct {
	LocalAddress string `protobuf:"bytes,30,opt,name=local_address,json=localAddress,oneof"`
}

func (*NetworkAddress_Ipv4Address) isNetworkAddress_Address()  {}
func (*NetworkAddress_Ipv6Address) isNetworkAddress_Address()  {}
func (*NetworkAddress_LocalAddress) isNetworkAddress_Address() {}

func (m *NetworkAddress) GetAddress() isNetworkAddress_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NetworkAddress) GetFamily() NetworkAddressFamily {
	if m != nil {
		return m.Family
	}
	return NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNKNOWN
}

func (m *NetworkAddress) GetIpv4Address() *IPv4AddressAndPort {
	if x, ok := m.GetAddress().(*NetworkAddress_Ipv4Address); ok {
		return x.Ipv4Address
	}
	return nil
}

func (m *NetworkAddress) GetIpv6Address() *IPv6AddressAndPort {
	if x, ok := m.GetAddress().(*NetworkAddress_Ipv6Address); ok {
		return x.Ipv6Address
	}
	return nil
}

func (m *NetworkAddress) GetLocalAddress() string {
	if x, ok := m.GetAddress().(*NetworkAddress_LocalAddress); ok {
		return x.LocalAddress
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkAddress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkAddress_OneofMarshaler, _NetworkAddress_OneofUnmarshaler, _NetworkAddress_OneofSizer, []interface{}{
		(*NetworkAddress_Ipv4Address)(nil),
		(*NetworkAddress_Ipv6Address)(nil),
		(*NetworkAddress_LocalAddress)(nil),
	}
}

func _NetworkAddress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkAddress)
	// address
	switch x := m.Address.(type) {
	case *NetworkAddress_Ipv4Address:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv4Address); err != nil {
			return err
		}
	case *NetworkAddress_Ipv6Address:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ipv6Address); err != nil {
			return err
		}
	case *NetworkAddress_LocalAddress:
		b.EncodeVarint(30<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.LocalAddress)
	case nil:
	default:
		return fmt.Errorf("NetworkAddress.Address has unexpected type %T", x)
	}
	return nil
}

func _NetworkAddress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkAddress)
	switch tag {
	case 10: // address.ipv4_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPv4AddressAndPort)
		err := b.DecodeMessage(msg)
		m.Address = &NetworkAddress_Ipv4Address{msg}
		return true, err
	case 20: // address.ipv6_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IPv6AddressAndPort)
		err := b.DecodeMessage(msg)
		m.Address = &NetworkAddress_Ipv6Address{msg}
		return true, err
	case 30: // address.local_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Address = &NetworkAddress_LocalAddress{x}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkAddress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkAddress)
	// address
	switch x := m.Address.(type) {
	case *NetworkAddress_Ipv4Address:
		s := proto.Size(x.Ipv4Address)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkAddress_Ipv6Address:
		s := proto.Size(x.Ipv6Address)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NetworkAddress_LocalAddress:
		n += proto.SizeVarint(30<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.LocalAddress)))
		n += len(x.LocalAddress)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*IPv4Address)(nil), "capsule8.api.v0.IPv4Address")
	proto.RegisterType((*IPv4AddressAndPort)(nil), "capsule8.api.v0.IPv4AddressAndPort")
	proto.RegisterType((*IPv6Address)(nil), "capsule8.api.v0.IPv6Address")
	proto.RegisterType((*IPv6AddressAndPort)(nil), "capsule8.api.v0.IPv6AddressAndPort")
	proto.RegisterType((*NetworkAddress)(nil), "capsule8.api.v0.NetworkAddress")
	proto.RegisterEnum("capsule8.api.v0.NetworkAddressFamily", NetworkAddressFamily_name, NetworkAddressFamily_value)
}

func init() { proto.RegisterFile("capsule8/api/v0/types.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 382 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0x5f, 0x6b, 0xb2, 0x50,
	0x1c, 0xc7, 0xb3, 0x1e, 0x8c, 0x4e, 0x7f, 0x1e, 0x39, 0x74, 0x11, 0x2b, 0x9a, 0x38, 0x62, 0xb1,
	0x0b, 0x8d, 0x0a, 0xd9, 0xcd, 0x2e, 0x6c, 0x15, 0x45, 0xcd, 0xe2, 0xd4, 0x88, 0xed, 0xc6, 0x59,
	0xb9, 0x92, 0xd9, 0x8e, 0xa8, 0x19, 0xbd, 0x90, 0x5d, 0xef, 0xad, 0x8e, 0x4e, 0xea, 0xaa, 0x55,
	0x8c, 0xdd, 0xfd, 0xd4, 0xef, 0xf7, 0xe3, 0xe7, 0xfc, 0xe0, 0x80, 0xec, 0x44, 0x35, 0xed, 0xa5,
	0xa1, 0xdd, 0x0a, 0xaa, 0xa9, 0x0b, 0x6e, 0x49, 0x70, 0xd6, 0xa6, 0x66, 0xf3, 0xa6, 0x85, 0x1d,
	0x0c, 0xff, 0xfb, 0x1f, 0x79, 0xd5, 0xd4, 0x79, 0xb7, 0xc4, 0x5d, 0x83, 0x78, 0xbb, 0xef, 0x56,
	0xa5, 0xe9, 0xd4, 0xd2, 0x6c, 0x1b, 0x66, 0x40, 0x54, 0xdd, 0x8e, 0x19, 0x8a, 0xa5, 0x8a, 0x51,
	0xe4, 0x3f, 0x72, 0x2f, 0x00, 0xee, 0x04, 0xa5, 0xf7, 0x69, 0x1f, 0x5b, 0x0e, 0x14, 0xf7, 0xf3,
	0xf1, 0x72, 0x8e, 0x3f, 0xf8, 0x03, 0xbf, 0xd3, 0x0a, 0x68, 0x10, 0x82, 0x7f, 0x26, 0xb6, 0x9c,
	0x4c, 0x98, 0xa5, 0x8a, 0x49, 0x44, 0x66, 0xae, 0x42, 0x54, 0x44, 0xe9, 0x3b, 0x32, 0xd7, 0x67,
	0x73, 0xc2, 0xa5, 0x11, 0x99, 0x21, 0x03, 0x22, 0x06, 0x5e, 0x91, 0x16, 0x8d, 0x36, 0xa3, 0xa7,
	0x25, 0xfe, 0x49, 0x4b, 0xfc, 0x95, 0xd6, 0x47, 0x18, 0xa4, 0x64, 0xcd, 0x59, 0x61, 0xeb, 0xcd,
	0x57, 0xbb, 0x03, 0xf4, 0xab, 0xba, 0xd0, 0x8d, 0x35, 0xa1, 0xa7, 0xca, 0x85, 0x1f, 0xf4, 0xfd,
	0x42, 0x93, 0x84, 0x91, 0x57, 0x82, 0x2d, 0x90, 0xd0, 0x4d, 0xb7, 0xaa, 0xf8, 0x8a, 0x80, 0x28,
	0x5e, 0x9d, 0xdb, 0x9c, 0x77, 0xb0, 0x56, 0x08, 0xc5, 0x37, 0x55, 0x5f, 0x64, 0x4b, 0x12, 0x03,
	0x52, 0xfa, 0x34, 0x49, 0x3c, 0x4a, 0x0a, 0xb6, 0x5d, 0x00, 0x49, 0x03, 0x4f, 0x54, 0x23, 0x40,
	0xe5, 0x59, 0xaa, 0x18, 0x6b, 0x85, 0x50, 0x82, 0xbc, 0xf6, 0x62, 0xb5, 0x58, 0xb0, 0xd8, 0x9b,
	0x4f, 0x0a, 0xa4, 0x8f, 0x1d, 0x13, 0x72, 0x20, 0x2f, 0x37, 0x86, 0xa3, 0x1e, 0xea, 0x28, 0x52,
	0xbd, 0x8e, 0x1a, 0x83, 0x81, 0xd2, 0x94, 0x1e, 0xda, 0xdd, 0x27, 0xe5, 0x51, 0xee, 0xc8, 0xbd,
	0x91, 0xcc, 0x84, 0xe0, 0x25, 0xc8, 0x9e, 0xc8, 0xb4, 0xe5, 0xc6, 0x90, 0xa1, 0x20, 0x0b, 0x72,
	0x67, 0x02, 0x22, 0x13, 0x3e, 0x93, 0xe8, 0xf6, 0xee, 0xa5, 0x2e, 0x13, 0xa9, 0xe5, 0x9e, 0x2f,
	0x66, 0xba, 0x33, 0x5f, 0x8e, 0xf9, 0x09, 0x5e, 0x08, 0x07, 0xd7, 0x62, 0x4c, 0x93, 0x1b, 0x51,
	0xf9, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x5f, 0xc4, 0x18, 0xf9, 0x30, 0x03, 0x00, 0x00,
}
